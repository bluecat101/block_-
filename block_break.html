<!-- 遺伝子長の数だけ使い切らない可能性があるので、使った遺伝子長の後ろ側を子の生成時に乱数で指定するのあり。 -->

<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ブロック崩し -遺伝的アルゴリズム-</title>
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="robots" content="noindex,nofollow">
<script src="choice.js"></script>
<script src="selection.js"></script>
<script src="crossover.js"></script>
<script src="MGG.js"></script>
<script src="save.js"></script>
<script src="GA.js"></script>
<script src="helper.js"></script>
<style type="text/css">

body{ -moz-user-select: none; -webkit-user-select: none; -ms-user-select: none; font-size: 20px;}
canvas{ border: none; position: absolute; left: 10px; top: 10px;}
#graph2{ cursor: pointer;}
#data{ position: relative; top: 410px;}
.setting{ position: relative; left: 20px;}
.status{ width: 70px; font-size: inherit;}
.button{ font-size: inherit;}

</style>
</head>
<body>

<canvas id='graph'></canvas>  <!-- 初期画面用、バーとボール用-->
<canvas id='graph2'></canvas> <!-- ブロック-->
<div id='data'>
    <!-- <input type='checkbox' id='resetEverytime' checked>落ちたらリセット<br> -->
    <span>状態</span></br>
    <div class="setting">
      世代数 <input type="text" id="generation" class="status" value="">
      個体数 <input type="text" id="individual" class="status" value="">
      遺伝子数  <input type="text" id="chrom" class="status" value="">
    </div>
    <span>実行</span></br>
    <div class="setting">
      <input type='button' class='button' id='quickTry' value='描画せずに実行'>
      <input type="button" class='button' id="try" value="描画して実行">
      <input type="button" class='button' id="reset" value="リセット"></br>
    </div>
    <span>速度(FrameRate)</span></br>
    <div class="setting">
      <input type="text" id="frameRate" value="">
      <input type='button' class='button' id='frameRateDecide' value='決定'></br>
      <input type='button' class='button' id='slow' value='<<遅く'>
      <input type="button" class='button' id="fast" value="速く>>"></br>
      <input type="button" class='button' id="save" value="保存"></br>
    </div>
  </div>

<script>
var N = 100;//個体数
var individual = new Array(N);
var chrom = 1000;//遺伝子数
var GENERATION = 100;
const CHOICE_TYPE = "elite" //--- "elite","MGG-rulet"
const CROSSOVER_TYPE = "single" //--- "single","double"
var FRAME_RATE = 1;
const NUM_OF_CHILD =32; // 2の累乗
var best = new Array(2);
var isFinish = false;
var record = [];
var count_n;
var count_ge;
var score = 0;
var numberOfBreakedBlock;
var recordIndevidual;
// recordIndevidual[0].push("1");
// recordIndevidual[0].push("2");
// recordIndevidual[0].push("3");

// (function(){
  
  //バーを動かす関数
  function moveBar(In){
    if(numberOfFrames%10 != 0){
      return;
    }
      var action = In[numberOfFrames/10];
      // if(action==0) reward += 10;
      var tempX = bar.x+action*30; //左右に30ピクセルまたは動かない
      if (tempX<p.r) tempX = p.r; //左の壁に当たったら、それ以上左へは行かない
      else if (tempX>w-p.r) tempX = w-p.r; //右の壁に当たったらそれ以上右へは行かない
      bar.x = tempX;
  };

  function d(ID){ return document.getElementById(ID);}
  d("generation").value = GENERATION;
  d("individual").value = N;
  d("chrom").value = chrom;
  d("frameRate").value = FRAME_RATE;

  var timer;
  var paused = false, gameOver = false, gameEnded = true;
  // var numberOfBalls = 0; //使用したボールの数
  var numberOfFrames = 0; //かかったフレーム数（÷33＝時間（秒））
  var graph = d('graph'), graph2 = d('graph2');
  var g = graph.getContext('2d'), g2 = graph2.getContext('2d');
  var w = 600, h = 400;
  graph.width = graph2.width = w; graph.height = graph2.height = h;
  g.fillStyle = '#000';
  g.fillRect(0,0,w,h);
  g.save();
  g.font = '30px Arial';
  g.fillStyle = 'white';
  g.fillText('Click to Start',210,220);
  g.restore();

  // pはボール。順にx座標、y座標、半径、速度x成分、速度y成分,色
  var p = {x: 300, y: 20, r: 10, vx: 0, vy: 0, color: '#fff'};

  //barは棒。x座標、yは厚み、Lは長さの半分、edgeは角度が付き始める点の端からの距離
  var bar = {x: 300, y: 10, L: 50, edge: 45, color: '#ff0'};

  //bはブロック。b.xとb.yがともに配列で、xy座標を示す。wはwidthで幅、hはheightで高さ。全て同じ大きさの長方形
  var b = {x: [], y: [], w: 20, h: 10, color: '#88f'};

  var numberOfBreakedBlock  = 0;

  d('graph2').addEventListener('click',function(){
    if (gameEnded){
      gameEnded = false;
      reset();
      drawBG();
      mainLoop();
    }
    else if (paused){
      paused = false;
      drawBG();
      mainLoop();
    }
    else{
      paused = true;
      clearTimeout(timer);
      g2.font = '30px Arial';
      g2.fillStyle = 'white';
      g2.fillText('paused',250,220);
    }
  },false);

  function reset(){
    bar.x = 300;
    p.x = bar.x; p.y = bar.y+p.r;
    var angle = Math.PI*(10)/180;//Math.PI*(Math.random()*60-30)/180; //-30～30
    p.vx = Math.sin(angle)*12; p.vy = Math.cos(angle)*12; //cosとsinの反転に注意
    b.x = []; b.y = [];
    for (var i=0; i<3; i++) for (var j=0; j<11; j++){
        b.x.push(w/2-10*b.w+j*b.w*2);
        b.y.push(340-i*b.h*2);
    }
    if(!isFinish){
      next_individual();
    }
    numberOfBreakedBlock  = score = numberOfFrames = 0;
    // score = numberOfBalls = numberOfFrames = 0;
  }

  function mainLoop(){
    g.fillStyle = '#000';
    g.fillRect(0,0,w,h);
    g.setTransform(1,0,0,-1,0,h);

    //ボールの描画
    g.beginPath();
    g.arc(p.x,p.y,p.r,0,2*Math.PI);
    g.fillStyle = p.color;
    g.fill();
    //ボールの描画

    //バーの描画
    g.fillStyle = bar.color;
    g.fillRect(bar.x-bar.L+p.r+3,0,(bar.L-p.r-3)*2,bar.y); //±3は"遊び"

    //ボールを現在の速度をもとに移動させる
    p.x += p.vx;
    p.y += p.vy;

    //バーを動かす
    if(isFinish){moveBar(individual[best[1]]);}
    else{moveBar(individual[count_n]);}


    //ここから衝突判定。まずはブロック
    if (p.y>=280){
      for (var i=0,I=b.x.length,hit=false; i<I; i++){
        if ((p.y-b.y[i])*p.vy<0 && Math.abs(p.x-b.x[i])<=b.w && Math.abs(p.y-b.y[i])<=b.h+p.r){
            // x座標においてボールがぶつかったかどうか
            p.vy *= -1; hit = true; break;
        }
        else if ((p.x-b.x[i])*p.vx<0 &&Math.abs(p.y-b.y[i])<=b.h && Math.abs(p.x-b.x[i])<=b.w+p.r){
            // y座標においてボールがぶつかったかどうか
            p.vx *= -1; hit = true; break;
        }
      }
      if (hit){
        numberOfBreakedBlock +=1;
        score += 10;
        b.x.splice(i,1); b.y.splice(i,1);
        drawBG(); // ブロックを再描画
        if (b.x.length<=0){
            // 全てのブロックが消えたかどうか
            gameEnded = true;
            d('graph2').style.cursor = 'pointer';
            g2.font = '40px Arial';
            g2.fillStyle = 'white';
            g2.fillText('SUCCESS !',200,200);
            var timeLapse = Math.floor(100*numberOfFrames/33)/100;
            g2.fillText(timeLapse+' sec',220,250);
            return;
        }
      }
    }
    //↓衝突判定。ここから壁
    if (p.x>w-p.r){ p.x = w-p.r; p.vx *= -1;} //right
    if (p.x<p.r){   p.x = p.r; p.vx *= -1;} //left
    if (p.y>h-p.r){ p.y = h-p.r; p.vy *= -1;} //up
    if (p.y<p.r+bar.y){
      var p_bar = Math.abs(p.x-bar.x);
      if (!gameOver && p_bar<=bar.L){
        score += 1;
        drawBG();
        var X = (p.x>bar.x) ? 1 : -1; //衝突点のバーの法線ベクトル(X,1);
        if (p_bar<=bar.L-bar.edge) X = 0; //バーの中央
        else if (p_bar<=bar.L-bar.edge/3) X *= (p_bar-bar.L+bar.edge)/100; //0～0.3（バーの端は約73°）
        else X *= 0.3;
        var L = Math.sqrt(X*X+1); //法線ベクトルの長さ
        var vec = {x: X/L, y: 1/L}; //法線ベクトルの正規化
        var dot = vec.x*p.vx+vec.y*p.vy;
        p.y = p.r+bar.y;
        p.vx -= 2*dot*vec.x;
        p.vy -= 2*dot*vec.y;
        if (Math.abs(p.vx)/p.vy>1.5){ //角度が付き過ぎないよう調整
          var v2 = p.vx*p.vx+p.vy*p.vy;
          p.vy = Math.sqrt(v2/3.25);
          p.vx = (p.vx<0) ? -p.vy*1.5 : p.vy*1.5;
        }
      }
      else if (!gameOver && p.y<p.r) gameOver = true;
      else if (gameOver && p.y<-p.r){
        gameOver = false;
        reset();
        numberOfFrames = -1;;
        drawBG();
      }
    }
    numberOfFrames++;
    timer = setTimeout(mainLoop,FRAME_RATE); //30ミリ秒後にmainloop実行 (-> 1秒に約30回繰り返す)
  }
  



  //↓ブロックの描画。動きがないのに毎回描くのは無駄なので、別にして処理を節約。
  function drawBG(){
    g2.clearRect(0,0,w,h);
    g2.font = '20px Arial';
    g2.fillStyle = '#fff';
    g2.fillText('ブロック数:　'+numberOfBreakedBlock ,15,25);
    g2.fillText('世代数:　'+count_ge,190,25);
    g2.fillText('個体番号:　'+(parseInt(count_n)+1),330,25);
    g2.fillText('Score:　'+score,480,25);
    g2.save();
    g2.setTransform(1,0,0,-1,0,h);
    g2.fillStyle = '#ccf';
    for (var i=0,I=b.x.length; i<I; i++) g2.fillRect(b.x[i]-b.w,b.y[i]-b.h,2*b.w,2*b.h);
    g2.fillStyle = b.color;
    for (var i=0; i<I; i++) g2.fillRect(b.x[i]-b.w+1,b.y[i]-b.h+1,2*b.w-2,2*b.h-2);
    g2.restore();
  };

  function next_individual(){
    if(count_ge == GENERATION && count_n == N-1){
      isFinish = true;
      var sortedEval = sortEvaluation(individual);
      saveTmp(sortedEval);
      best = [sortedEval[0][0],sortedEval[0][1]];
      count_ge = GENERATION;
      console.log(best);
      count_n = best[1];
      return;
    }
    tmp = [score,numberOfFrames];
    // console.log("tuuka");
    recordIndevidual[count_n] = tmp;
    count_n++;
    if(count_n == N){
      evolve();
      count_ge++;
      //--- 初期化
      count_n = 0;
      console.log(recordIndevidual);
    } 
  }



  console.log("start");
  initWithChrom();

  // 実行された時の処理
  document.getElementById("try").addEventListener("click", function(){
    gameEnded = false;
    init();
    reset();
    drawBG();
    mainLoop();
  })

  document.getElementById("quickTry").addEventListener("click", function(){
    gameEnded = false;
    init();
    isFinish = true;

    //操作をGENERATION回繰り返す
    console.log(recordIndevidual[0][0]);
    loopForEvolve();
    reset();
    drawBG();
    mainLoop();
  },false);




  document.getElementById("frameRateDecide").addEventListener("click", function(){
    FRAME_RATE = d("frameRate").value;
  });
  document.getElementById("slow").addEventListener("click", function(){
    FRAME_RATE *= 2;
    d("frameRate").value = FRAME_RATE;
  });
  document.getElementById("fast").addEventListener("click", function(){
    FRAME_RATE=Math.ceil(FRAME_RATE/2);
    d("frameRate").value = FRAME_RATE;
  });
  document.getElementById("save").addEventListener("click", function(){
    saveCSV(record);
  });
  document.getElementById("reset").addEventListener("click", function(){
    clearTimeout(timer);
    var paused = false, gameOver = false, gameEnded = true
    g.fillStyle = '#000';
    g.fillRect(0,0,w,h);
    g2.clearRect(0,0,w,h);
    g.font = '30px Arial';
    g.fillStyle = 'white';
    g.fillText('Click to Start',210,220);
    console.clear();
    console.log("RESET");
    initWithChrom();
  });
// })();
</script>
</body>
</html>

